# 简答题
## 问题一
游戏对象运动的本质是什么
游戏对象运动的本质是游戏对象transform属性的position、rotation和scale等属性的变化。
## 问题二
请用三种以上的方法实现物体的抛物运动。
1.使用Vector3.MoveTowards方法
完整代码
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class movewithMoveTowards : MonoBehaviour {
    private Vector3 g;
    private Vector3 vy;
    private Vector3 vx;
    private float step;
	// Use this for initialization
	void Start () {
        step = Time.deltaTime;
        g = new Vector3(0, 9.8f, 0);
        vy = new Vector3(0, 50, 0);
        vx = new Vector3(0, 0, 30);
    }
	
	// Update is called once per frame
	void FixedUpdate () {
        Vector3 target;
        target = this.transform.position + (vy + vx) * step; 
        this.transform.position=Vector3.MoveTowards(this.transform.position, target, step);
        vy -= g * step;
        Debug.Log(transform.position.ToString());
	}
}

```

2.使用transform.Translate方法
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class movewithTranslate : MonoBehaviour {
    private Vector3 g;
    private Vector3 vy;
    private Vector3 vx;
    private float step;
    // Use this for initialization
    void Start()
    {
        step = Time.deltaTime;
        g = new Vector3(0, 9.8f, 0);
        vy = new Vector3(0, 50, 0);
        vx = new Vector3(0, 0, 3);
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        Vector3 target = (vy + vx) * step;
        transform.Translate(target);
        vy -= g * step;
        Debug.Log(transform.position.ToString());
    }
}

```

3.使用rigidbody
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class movewithGravity : MonoBehaviour {

    Rigidbody rb;
	// Use this for initialization
	void Start () {
        Physics.gravity = new Vector3(0, -9.8f, 0);
        rb = this.GetComponent<Rigidbody>();
        rb.velocity = new Vector3(0, 20, 10);
	}
	
	// Update is called once per frame
	void FixedUpdate () {
        Debug.Log(transform.position.ToString());
	}
}

```
## 问题三
写一个程序，实现一个完整的太阳系，其他星球围绕太阳的转速必须不一样，且不在一个法平面上。
碰到了一个问题：rotateAround的原理与预期目标不太相符合。rotateAround接受三个参数：原点坐标origin，法线向量axis和环绕速度，其行为本质是以物体所在的点作一个与法线向量正交的平面，以法线向量在该平面的垂点作圆周运动。这样就有一个问题：圆周运动的点与原点坐标不重合。
我所使用的方法是先压缩维度，将变化维度局限在xy平面上；再作一条向量与法线向量垂直，通过计算直接算出以原点坐标为圆周运动圆心所需要的物体坐标，然后变化物体。
同时出于科学考虑，使用开普勒第三定律来决定行星物体的运动速度。
主体部分代码（planetMove.cs）
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class planetMove : MonoBehaviour {

	public Transform origin;
	public float speed;
	float ry,rx;
	float px,py;
	const int Kepler = 8000;//利用开普勒第三定律算得物体线速度的平方与半径的乘积是一个常数

	// Use this for initialization
	void Start () {
		origin = GameObject.Find ("sun").transform;
		rx = Random.Range (10, 50);
		ry = Random.Range (10, 50);
		Debug.Log (this.transform.name.ToString()+":"+rx.ToString()+" "+ry.ToString());

		float nx,ny;
		nx = 1;
		ny = -1 * rx / ry;
		float dist = Vector3.Distance (origin.position, this.transform.position);
		float ratio = dist / Mathf.Sqrt (ny * ny + 1);
		px = 1 * ratio;
		py = ny * ratio;
		this.transform.position = new Vector3 (px, py, 0);

		speed = Mathf.Sqrt (Kepler / dist);
	}
	
	// Update is called once per frame
	void Update () {
		Vector3 axis = new Vector3 (rx, ry, 0);
		this.transform.RotateAround (origin.position, axis, speed * Time.deltaTime);
		this.transform.Rotate (0,50 * Time.deltaTime, 0);
	}
}

```