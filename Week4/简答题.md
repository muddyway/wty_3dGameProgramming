# 简答题
## 问题一
游戏对象运动的本质是什么
游戏对象运动的本质是游戏对象transform属性的position、rotation和scale等属性的变化。
## 问题二
请用三种以上的方法实现物体的抛物运动。
1.使用Vector3.MoveTowards方法
完整代码
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class movewithMoveTowards : MonoBehaviour {
    private Vector3 g;
    private Vector3 vy;
    private Vector3 vx;
    private float step;
	// Use this for initialization
	void Start () {
        step = Time.deltaTime;
        g = new Vector3(0, 9.8f, 0);
        vy = new Vector3(0, 50, 0);
        vx = new Vector3(0, 0, 30);
    }
	
	// Update is called once per frame
	void FixedUpdate () {
        Vector3 target;
        target = this.transform.position + (vy + vx) * step; 
        this.transform.position=Vector3.MoveTowards(this.transform.position, target, step);
        vy -= g * step;
        Debug.Log(transform.position.ToString());
	}
}

```

2.使用transform.Translate方法
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class movewithTranslate : MonoBehaviour {
    private Vector3 g;
    private Vector3 vy;
    private Vector3 vx;
    private float step;
    // Use this for initialization
    void Start()
    {
        step = Time.deltaTime;
        g = new Vector3(0, 9.8f, 0);
        vy = new Vector3(0, 50, 0);
        vx = new Vector3(0, 0, 3);
    }

    // Update is called once per frame
    void FixedUpdate()
    {
        Vector3 target = (vy + vx) * step;
        transform.Translate(target);
        vy -= g * step;
        Debug.Log(transform.position.ToString());
    }
}

```

3.使用rigidbody
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class movewithGravity : MonoBehaviour {

    Rigidbody rb;
	// Use this for initialization
	void Start () {
        Physics.gravity = new Vector3(0, -9.8f, 0);
        rb = this.GetComponent<Rigidbody>();
        rb.velocity = new Vector3(0, 20, 10);
	}
	
	// Update is called once per frame
	void FixedUpdate () {
        Debug.Log(transform.position.ToString());
	}
}

```
## 问题三
写一个程序，实现一个完整的太阳系，其他星球围绕太阳的转速必须不一样，且不在一个法平面上。
碰到了一个问题：rotateAround的原理与预期目标不太相符合。rotateAround接受三个参数：原点坐标origin，法线向量axis和环绕速度，其行为本质是以物体所在的点作一个与法线向量正交的平面，以法线向量在该平面的垂点作圆周运动。这样就有一个问题：圆周运动的点与原点坐标不重合。
我所使用的方法是先压缩维度，将变化维度局限在xy平面上；再作一条向量与法线向量垂直，通过计算直接算出以原点坐标为圆周运动圆心所需要的物体坐标，然后变化物体。
同时出于科学考虑，使用开普勒第三定律来决定行星物体的运动速度。
主体部分代码（planetMove.cs）
```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class planetMove : MonoBehaviour {

	public Transform origin;
	public float speed;
	float ry,rx;
	float px,py;
	const int Kepler = 8000;//利用开普勒第三定律算得物体线速度的平方与半径的乘积是一个常数

	// Use this for initialization
	void Start () {
		origin = GameObject.Find ("sun").transform;
		rx = Random.Range (10, 50);
		ry = Random.Range (10, 50);
		Debug.Log (this.transform.name.ToString()+":"+rx.ToString()+" "+ry.ToString());

		float nx,ny;
		nx = 1;
		ny = -1 * rx / ry;
		float dist = Vector3.Distance (origin.position, this.transform.position);
		float ratio = dist / Mathf.Sqrt (ny * ny + 1);
		px = 1 * ratio;
		py = ny * ratio;
		this.transform.position = new Vector3 (px, py, 0);

		speed = Mathf.Sqrt (Kepler / dist);
	}
	
	// Update is called once per frame
	void Update () {
		Vector3 axis = new Vector3 (rx, ry, 0);
		this.transform.RotateAround (origin.position, axis, speed * Time.deltaTime);
		this.transform.Rotate (0,50 * Time.deltaTime, 0);
	}
}

```
#牧师与魔鬼
##问题描述
>Priests and Devils is a puzzle game in which you will help the Priests and Devils to cross the river within the time limit. There are 3 priests and 3 devils at one side of the river. They all want to get to the other side of this river, but there is only one boat and this boat can only carry two persons each time. And there must be one person steering the boat from one side to the other side. In the flash game, you can click on them to move them and click the go button to move the boat to the other direction. If the priests are out numbered by the devils on either side of the river, they get killed and the game is over. You can try it in many > ways. Keep all priests alive! Good luck!

牧师与魔鬼是一个十分有趣的益智游戏。你需要帮助牧师与魔鬼在规定的时间限制内过河。在河的一边有三个牧师和三个魔鬼，他们都想要到河的对岸去。但是河里只有一艘船，而且一次只能够运送两个人。并且，每次都必须有一个人将船从河的一头开到另一头。在实际游戏中，你可以通过点击来移动它们上传并且点击go按钮来将船移动到对岸。如果牧师的数量少于魔鬼，它们就会被吃掉。你可以进行多次尝试。记得保证所有的牧师存活。祝你好运！
程序